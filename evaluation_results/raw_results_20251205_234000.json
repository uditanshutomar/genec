{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7290322580645164,
      "coupling": 0.9359708485163972,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7454545454545456,
      "coupling": 1.0,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ],
      "cohesion": 0.6766666666666665,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6363636363636366,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.6571428571428571,
      "coupling": 0.9565217391304346,
      "quality_score": 30.0
    },
    {
      "id": 5,
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 6,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 8,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for all order-related price calculations including shipping, discounts, taxes, and totals. Extracting them into an OrderPriceCalculator class isolates financial computation logic and improves reusability across different order processing contexts.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes) and provide breakdowns and totals. The orderPriceCalculator field supports these calculations, indicating this cluster handles all price-related computations.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"order pricing\" domain. They represent a cohesive financial calculation subsystem that transforms order data into monetary values. This is a classic computational responsibility that operates on order information to produce pricing results.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts (quotes, invoices, receipts)\n- Complexity reduction: Removes financial calculation complexity from the main order class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate computational concerns. The Calculator pattern is appropriate here as these methods perform related mathematical operations on order data to produce financial results.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart abstraction that manages item collections, quantities, and cart-level calculations. Extracting them creates a reusable component with clear boundaries that encapsulates all cart-related operations and state management.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle calculations related to those items. The primary responsibility is maintaining and manipulating a shopping cart or order line items, including adding/removing items, updating quantities, calculating totals, and providing various views of the cart contents.\n\nStep 2: Shared Concept/Domain\nAll members represent the \"Shopping Cart\" domain concept. The fields (items, itemQuantities, totalAmount) store the cart state, while the methods provide cart operations like item management, quantity updates, total calculations, and cart queries. The buildOrderConfirmationEmailBody() and logAudit() methods also operate on this cart data for downstream processes.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart management logic from other business concerns\n- Code reusability: Cart functionality can be reused across different order contexts (web, mobile, API)\n- Complexity reduction: Removes cart-specific logic from the main class, making it more focused\n- Testability: Cart operations can be unit tested independently with clear boundaries\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate the \"shopping cart\" concern. The extracted class will have high cohesion (all methods operate on cart items and quantities) and low coupling (minimal dependencies beyond basic data types and inventory checks).\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ]
    },
    {
      "class_name": "WarehouseInventoryTracker",
      "rationale": "These methods and field form a cohesive inventory management unit that tracks warehouse stock levels, identifies low inventory situations, and maintains audit logs. Extracting them creates a focused class with high cohesion around warehouse inventory operations and reduces coupling with unrelated business logic.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage warehouse inventory operations. getLowStockItems(int) identifies items below a threshold, updateWarehouseStock(String,int) modifies inventory quantities, and logAudit(String) records inventory-related activities. The warehouseInventoryTracker field likely maintains the current state of warehouse stock levels.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"warehouse inventory management\" domain. They represent a cohesive subsystem that tracks stock levels, identifies low inventory situations, updates quantities, and maintains audit trails for inventory changes. This is a well-defined business concept with clear boundaries.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all warehouse inventory concerns into one focused class\n- Code reusability: Inventory tracking logic can be reused across different warehouse operations\n- Complexity reduction: Removes inventory management complexity from the original God class\n- Testability: Inventory operations can be unit tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate inventory management concerns. The extraction creates a cohesive unit that encapsulates warehouse stock tracking, which is a distinct business capability that should be independently maintainable and testable.\n",
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ]
    },
    {
      "class_name": "OrderTransactionWorkflow",
      "rationale": "These methods form a cohesive workflow that orchestrates the complete order transaction process, coordinating payment processing, inventory management, and customer notifications. Extracting them creates a focused class responsible for managing the multi-step transaction lifecycle, improving testability and separation of concerns.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order transactions - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order transaction successfully.\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"order transaction\" domain. They represent the coordinated workflow that occurs when processing an order: payment handling (generateTransactionId, processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus), and customer communication (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail). The orderProcessor field likely coordinates these operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates transaction workflow logic from other business concerns\n- Testability: Transaction scenarios can be unit tested independently with mocked dependencies\n- Reusability: Transaction logic can be reused across different order types or contexts\n- Complexity reduction: Removes complex multi-step workflow logic from the original class\n- Maintainability: Changes to transaction flow are localized to one class\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate complex workflow orchestration. The methods represent a cohesive transaction workflow that coordinates multiple subsystems (payment, inventory, notifications) to achieve a single business goal - completing an order transaction.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for order fulfillment operations including discount application, total calculation, shipping logistics, and delivery estimation. Extracting them creates a focused class that encapsulates the complete fulfillment workflow while reducing complexity in the original order class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, determine delivery dates, and handle shipping logistics. The primary responsibility is orchestrating the fulfillment process from discount application through delivery estimation.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They work together to transform an order from its initial state to a ready-to-ship state with calculated pricing, applied discounts, and shipping arrangements. The shipping address fields form a cohesive data structure, while the methods perform fulfillment calculations and logistics.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates fulfillment logic from other order concerns like creation or payment\n- Code reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity reduction: Removes complex calculation and logistics code from the main order class\n- Testability: Fulfillment scenarios can be tested independently with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The methods have high cohesion as they all contribute to order fulfillment, and the extraction creates low coupling by isolating fulfillment logic from other order responsibilities.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
