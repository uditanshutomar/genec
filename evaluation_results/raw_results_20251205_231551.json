{
  "clusters_all": [
    {
      "id": 5,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "calculateShippingCost()",
        "checkInventoryAvailability()",
        "clearItems()",
        "generateOrderId()",
        "getCustomerId()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "recalculateSubtotal()",
        "releaseInventory()",
        "removeItem(String)",
        "reserveInventory()",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "<init>(String,String,String)",
        "getShippingMethodMultiplier()",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "customerId",
        "items",
        "itemQuantities",
        "packageWeight",
        "warehouseStock",
        "reservedItems"
      ],
      "cohesion": 0.6705882352941173,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 1,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "getAuditLog()",
        "logAudit(String)",
        "setCustomerTier(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "customerTier",
        "discountPercentage",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.8181818181818183,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 0,
      "methods": [
        "buildOrderConfirmationEmailBody()",
        "getCustomerEmail()",
        "getOrderDate()",
        "getOrderId()",
        "getTotalAmount()",
        "sendEmail(String,String,String)",
        "sendOrderConfirmationEmail()",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "sendShippingNotificationEmail(String)",
        "logAudit(String)"
      ],
      "fields": [
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "totalAmount"
      ],
      "cohesion": 0.7291666666666666,
      "coupling": 0.9371428571428572,
      "quality_score": 35.0
    },
    {
      "id": 3,
      "methods": [
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)",
        "calculateShippingCost()"
      ],
      "fields": [
        "subtotal",
        "taxRate",
        "shippingCost",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.8066666666666668,
      "coupling": 0.9065082644628097,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "simulatePaymentGateway(String,String,BigDecimal)",
        "sendRefundNotificationEmail()",
        "releaseInventory()",
        "logAudit(String)",
        "reserveInventory()",
        "sendPaymentConfirmationEmail()",
        "sendEmail(String,String,String)"
      ],
      "fields": [
        "orderStatus",
        "paymentMethod",
        "paymentStatus",
        "transactionId"
      ],
      "cohesion": 0.8153846153846155,
      "coupling": 0.94240317775571,
      "quality_score": 40.0
    },
    {
      "id": 4,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 6,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderProcessor",
      "rationale": "These methods and fields form a cohesive unit responsible for managing the complete order processing workflow, from payment handling to inventory management and customer notifications. Extracting them into an OrderProcessor class creates a focused service that encapsulates the complex business logic of order fulfillment while improving testability and reusability.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete order processing lifecycle, from payment processing to inventory management to customer notifications. The core responsibility is orchestrating and managing all aspects of order fulfillment, including payment transactions, inventory operations, status tracking, and communication with customers.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"Order Processing\" domain. They represent a cohesive workflow that manages the state and operations of an order from payment initiation through completion, including payment gateway interactions, inventory management, email notifications, and audit logging. The fields (orderStatus, paymentMethod, paymentStatus, transactionId) directly support the order processing operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates complex order processing logic from other business concerns\n- Code Reusability: Order processing logic can be reused across different parts of the application\n- Complexity Reduction: Removes intricate payment and inventory workflows from the original class\n- Testability: Order processing scenarios can be unit tested in isolation with mock dependencies\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a Service Object that encapsulates the complex business process of order fulfillment. It implements the Single Responsibility Principle by focusing solely on order processing workflows and reduces coupling by centralizing related operations and state management.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "simulatePaymentGateway(String,String,BigDecimal)",
        "sendRefundNotificationEmail()",
        "releaseInventory()",
        "logAudit(String)",
        "reserveInventory()",
        "sendPaymentConfirmationEmail()",
        "sendEmail(String,String,String)"
      ],
      "fields": [
        "orderStatus",
        "paymentMethod",
        "paymentStatus",
        "transactionId"
      ]
    },
    {
      "class_name": "OrderNotificationService",
      "rationale": "These methods and fields form a cohesive notification service responsible for managing all order-related email communications. They share order data fields and collectively handle the complete workflow of building, sending, and auditing order notifications, making them ideal candidates for extraction into a dedicated service class.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share a primary responsibility of managing order-related email communications. The methods handle building email content, retrieving order information needed for emails, sending various types of order notifications (confirmation, payment, refund, shipping), and logging audit trails of these communications.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"order notification\" domain. They represent a cohesive subsystem that manages the complete lifecycle of order-related email communications, from data retrieval to content generation to actual sending and auditing.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all order email notification logic into one focused class\n- Code Reusability: The notification service can be reused across different order processing contexts\n- Complexity Reduction: Removes email-specific logic from the main order processing class\n- Testability: Email notification logic can be independently tested and mocked\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate cross-cutting concerns. It implements the Single Responsibility Principle by creating a dedicated service class for order notifications, and supports the Dependency Inversion Principle by allowing the main class to depend on an abstraction for notifications rather than handling email logic directly.\n",
      "methods": [
        "buildOrderConfirmationEmailBody()",
        "getCustomerEmail()",
        "getOrderDate()",
        "getOrderId()",
        "getTotalAmount()",
        "sendEmail(String,String,String)",
        "sendOrderConfirmationEmail()",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "sendShippingNotificationEmail(String)",
        "logAudit(String)"
      ],
      "fields": [
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "totalAmount"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart management system that handles item selection, quantity management, and inventory coordination. Extracting them creates a reusable component with clear boundaries between cart operations and other business logic, improving both maintainability and testability.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage shopping cart operations and inventory management. They handle adding/removing items, calculating costs, managing item quantities, checking stock availability, and coordinating inventory reservations. The primary responsibility is managing the lifecycle of items in a shopping context from selection through inventory coordination.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"shopping cart\" and \"inventory management\" domain. They represent a cohesive subsystem that bridges customer item selection with warehouse inventory operations. The fields (items, itemQuantities, warehouseStock, reservedItems) directly support the cart and inventory operations performed by the methods.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Separates cart/inventory logic from other business concerns\n- Code Reusability: Cart functionality can be reused across different order processing flows\n- Complexity Reduction: Original class becomes simpler by removing cart management complexity\n- Testability: Cart operations can be tested in isolation with mock inventory data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate cart management concerns. It creates a cohesive unit that encapsulates both the cart state and inventory coordination logic, following the principle of high cohesion by grouping related data and operations together.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "calculateShippingCost()",
        "checkInventoryAvailability()",
        "clearItems()",
        "generateOrderId()",
        "getCustomerId()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "recalculateSubtotal()",
        "releaseInventory()",
        "removeItem(String)",
        "reserveInventory()",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "<init>(String,String,String)",
        "getShippingMethodMultiplier()",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "customerId",
        "items",
        "itemQuantities",
        "packageWeight",
        "warehouseStock",
        "reservedItems"
      ]
    },
    {
      "class_name": "OrderProcessor",
      "rationale": "These methods and fields form a cohesive unit responsible for processing orders through discount application, pricing calculations, and audit tracking. Extracting them into an OrderProcessor class improves separation of concerns by isolating complex business logic while maintaining high cohesion around order processing responsibilities.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order processing operations including discount application, pricing calculations, customer tier management, and audit tracking. The main responsibility is managing the business logic around order pricing, discounts, and maintaining an audit trail of order modifications.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Processing\" domain concept. They form a cohesive subsystem that handles the complex business rules around order pricing (discounts, shipping costs, tier-based pricing) while maintaining audit capabilities for compliance and tracking purposes.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Separates order processing logic from other concerns\n- Code reusability: Order processing logic can be reused across different order types or contexts\n- Complexity reduction: Original class becomes simpler by removing complex pricing and audit logic\n- Testability: Order processing rules can be tested in isolation with focused unit tests\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate business logic concerns. The Strategy pattern could be applied here for different discount calculation strategies, and the Command pattern supports the audit logging functionality. This extraction creates high cohesion around order processing responsibilities.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "getAuditLog()",
        "logAudit(String)",
        "setCustomerTier(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "customerTier",
        "discountPercentage",
        "auditLog",
        "lastModified"
      ]
    },
    {
      "class_name": "OrderFulfillmentService",
      "rationale": "These methods and fields form a cohesive unit responsible for managing the complete order fulfillment process, including pricing calculations, shipping logistics, and delivery estimation. Extracting them into an OrderFulfillmentService improves separation of concerns by isolating fulfillment operations from core order management, while providing a reusable component for order processing workflows.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment calculations and logistics. They calculate financial aspects (totals, taxes, discounts, shipping costs), manage shipping details (address, method, delivery estimates), and track changes through audit logging. The primary responsibility is managing the complete order fulfillment process from pricing to delivery.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"order fulfillment\" domain. The fields store shipping address components, costs, and rates, while the methods perform calculations and operations related to order processing, shipping, and delivery. This represents a cohesive subsystem that bridges order management and logistics.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates order fulfillment logic from other business concerns\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Removes complex calculation and shipping logic from the main class\n- Testability: Fulfillment calculations and shipping logic can be tested independently\n- Maintainability: Changes to shipping rules, tax calculations, or pricing logic are centralized\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. It creates a cohesive unit responsible for order fulfillment operations while reducing coupling with the original class. The extraction supports the Single Responsibility Principle by creating a focused component that handles the complete fulfillment workflow.\n",
      "methods": [
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)",
        "calculateShippingCost()"
      ],
      "fields": [
        "subtotal",
        "taxRate",
        "shippingCost",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
