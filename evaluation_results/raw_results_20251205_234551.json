{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7290322580645164,
      "coupling": 0.9359708485163972,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7454545454545456,
      "coupling": 1.0,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ],
      "cohesion": 0.6766666666666665,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6363636363636365,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.6571428571428571,
      "coupling": 0.9565217391304345,
      "quality_score": 30.0
    },
    {
      "id": 5,
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 6,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 8,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "WarehouseInventoryTracker",
      "rationale": "These methods and field form a cohesive unit responsible for tracking warehouse inventory levels, updating stock quantities, and maintaining audit logs of inventory changes. Extracting them creates a focused class with high cohesion that encapsulates all inventory tracking responsibilities.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage warehouse inventory operations. getLowStockItems(int) identifies items below a threshold, updateWarehouseStock(String,int) modifies inventory quantities, and logAudit(String) records inventory-related activities. The warehouseInventoryTracker field supports these operations by maintaining inventory state.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"warehouse inventory management\" domain. They represent a cohesive subsystem that tracks stock levels, updates quantities, identifies low-stock situations, and maintains audit trails for inventory changes. This is a well-defined business capability around inventory tracking.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates inventory tracking logic from other business concerns\n- Code reusability: Inventory tracking can be used across multiple warehouse operations\n- Complexity reduction: Removes inventory management complexity from the original class\n- Testability: Inventory operations can be unit tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate inventory management concerns. The cohesive set of inventory operations and state form a natural boundary that should be encapsulated in its own class, improving maintainability and following domain-driven design principles.\n",
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ]
    },
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for calculating all monetary aspects of an order including shipping, discounts, taxes, and totals. Extracting them into an OrderPriceCalculator class isolates financial computation logic and improves testability while reducing the complexity of the original class.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes) and provide breakdowns and totals. All methods are focused on computing and retrieving different aspects of order pricing.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Pricing\" domain concept. They form a cohesive calculation engine that handles all monetary computations related to an order, including base pricing, shipping, discounts, taxes, and final totals. The orderPriceCalculator field likely serves as a dependency for these calculations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts\n- Complexity reduction: Removes financial calculation complexity from the original class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate financial calculation concerns. It creates a specialized calculator that encapsulates order pricing logic, following the principle of high cohesion (all methods relate to price calculation) and enabling low coupling with the original class.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive unit responsible for managing a collection of items with quantities and performing cart-related calculations. Extracting them into a ShoppingCart class creates a focused domain object that encapsulates all cart operations, improving both reusability and maintainability by separating cart concerns from broader business logic.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle calculations related to those items. The core responsibility is maintaining an item collection state - adding, removing, updating quantities, and performing calculations based on the current item state. The methods like addItem(), removeItem(), updateItemQuantity(), and clearItems() manage the collection, while recalculateSubtotal(), calculateTotalAmount(), and getItemCount() perform computations on that collection.\n\nStep 2: Shared Concept/Domain\nThese members represent a \"shopping cart\" or \"order basket\" domain concept. They encapsulate the behavior of a container that holds items with quantities and can perform operations like inventory checking, total calculations, and item management. The buildOrderConfirmationEmailBody() method suggests this is specifically related to order processing, while logAudit() provides tracking capabilities for the cart operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates item collection management from other business concerns\n- Code reusability: The cart logic can be reused across different order contexts (web, mobile, API)\n- Complexity reduction: Removes cart-specific logic from the main class, making it more focused\n- Testability: Cart operations can be unit tested independently with mock data\n- Encapsulation: Cart state (items, quantities, totals) is properly encapsulated with its related operations\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a cohesive domain object. The extraction creates a high-cohesion class where all methods operate on the same data (items collection) and serve the same conceptual purpose (cart management). It also reduces coupling by isolating cart-specific operations from the broader business logic.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ]
    },
    {
      "class_name": "OrderTransactionOrchestrator",
      "rationale": "These methods form a cohesive unit responsible for orchestrating the complete order transaction workflow, coordinating payments, inventory management, and customer notifications. Extracting them creates a focused class that encapsulates the complex multi-step business process of order fulfillment, improving maintainability and testability of transaction logic.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order transactions - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order transaction successfully.\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"order transaction\" domain. They represent the coordinated workflow that occurs when processing an order: handling payments (process/refund), managing inventory (reserve/release), and communicating with customers (confirmation/notification emails). The orderProcessor field suggests this is already a recognized subsystem.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates complex transaction orchestration logic from other concerns\n- Testability: Transaction workflows can be unit tested independently with mocked dependencies\n- Reusability: Transaction logic can be reused across different order types or channels\n- Complexity reduction: Removes intricate multi-step business processes from the main class\n- Maintainability: Changes to transaction flow are contained within a single class\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate complex business workflow concerns. The methods represent a cohesive transaction orchestration responsibility that coordinates multiple subsystems (payment, inventory, notifications) to complete order processing.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for order fulfillment operations including discount application, total calculation, shipping arrangement, and delivery estimation. Extracting them creates a focused class that encapsulates the complete fulfillment workflow while reducing complexity in the original order class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, determine delivery dates, and handle shipping logistics. The primary responsibility is orchestrating the fulfillment process from pricing through delivery estimation.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They work together to transform an order from its initial state through pricing calculations, shipping arrangements, and delivery planning. The shipping address fields and methods that operate on them form a cohesive unit for managing the fulfillment workflow.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Separates fulfillment logic from other order concerns (creation, payment, etc.)\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Original class becomes more focused on core order management\n- Testability: Fulfillment calculations and shipping logic can be tested in isolation\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The methods have high cohesion as they all contribute to the order fulfillment process, and the extraction creates low coupling by isolating fulfillment operations from other order responsibilities.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
