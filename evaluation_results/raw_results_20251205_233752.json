{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7290322580645164,
      "coupling": 0.9359708485163972,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7454545454545456,
      "coupling": 1.0,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ],
      "cohesion": 0.6766666666666664,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6363636363636362,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "priceCalculator"
      ],
      "cohesion": 0.6571428571428571,
      "coupling": 0.9565217391304346,
      "quality_score": 30.0
    },
    {
      "id": 5,
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 6,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 8,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive financial calculation unit that computes all monetary aspects of an order including shipping, taxes, discounts, and totals. Extracting them into an OrderPriceCalculator class isolates complex pricing logic and creates a reusable component that can handle various pricing scenarios across different parts of the system.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order or transaction. They calculate various monetary components (shipping costs, discounts, taxes, totals) and provide breakdowns of pricing information. All methods work together to determine the final financial aspects of a purchase.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"pricing and financial calculation\" domain concept. They form a cohesive subsystem that handles all monetary computations, from individual cost components (shipping, tax, discounts) to the final total amount. The priceCalculator field suggests this is already a partially extracted calculation responsibility.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all financial calculation logic into one focused class\n- Code reusability: Pricing logic can be reused across different order types, checkout flows, or quote systems\n- Complexity reduction: Removes complex mathematical and business rule logic from the original class\n- Testability: Financial calculations can be thoroughly unit tested in isolation with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a specialized Calculator object. The extraction aligns with the Single Responsibility Principle by separating financial computation concerns from other business logic, creating a highly cohesive class with a clear mathematical responsibility.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "priceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart abstraction that manages item collections, quantities, and cart-related calculations. Extracting them creates a reusable component with high cohesion where all operations center around maintaining and calculating cart state. This separation improves the original class by removing cart management responsibilities and creates a focused, testable cart component.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle calculations related to those items. The core responsibility is maintaining an item collection state - adding, removing, updating quantities, and performing calculations based on the current item state. Methods like addItem, removeItem, updateItemQuantity manage the collection, while recalculateSubtotal and calculateTotalAmount perform computations on the collection.\n\nStep 2: Shared Concept/Domain\nThese members represent a \"Shopping Cart\" or \"Order Basket\" domain concept. They encapsulate the behavior of a container that holds items with quantities, tracks inventory, and calculates totals. The items and itemQuantities fields store the cart state, while methods provide cart operations. Even the email body building and audit logging are cart-specific operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart management from other business logic\n- Code Reusability: Cart logic can be reused across different order contexts (web, mobile, API)\n- Complexity Reduction: Original class becomes simpler by removing cart state management\n- Testability: Cart operations can be tested independently with focused unit tests\n- Encapsulation: Cart state (items, quantities) is properly encapsulated with its operations\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate the \"shopping cart\" concern. It creates a cohesive unit where all methods operate on the same data (items collection) and serve the same purpose (cart management). This aligns with the Single Responsibility Principle and improves separation of concerns.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ]
    },
    {
      "class_name": "InventoryTracker",
      "rationale": "These methods and field form a cohesive inventory management unit that tracks warehouse stock levels, updates quantities, and maintains audit logs. Extracting them into an InventoryTracker class isolates inventory concerns and creates a reusable component with a single, well-defined responsibility.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage warehouse inventory operations. They handle stock level monitoring (getLowStockItems), inventory changes (updateWarehouseStock), and maintain an audit trail of inventory operations (logAudit). The shared responsibility is tracking and managing warehouse inventory state and changes.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"warehouse inventory management\" domain. The warehouseInventoryTracker field serves as the central data structure, while the methods provide operations for monitoring stock levels, updating quantities, and logging inventory changes. This represents a cohesive inventory tracking subsystem.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all inventory tracking logic into one focused class\n- Code reusability: Inventory tracking can be reused across different warehouse systems or business contexts\n- Complexity reduction: Removes inventory management complexity from the original God class\n- Testability: Inventory operations can be unit tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a cohesive component. The extraction creates high cohesion (all methods work with inventory data) and low coupling (minimal dependencies on external business logic). This aligns with the Single Responsibility Principle by encapsulating inventory tracking concerns.\n",
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods represent a cohesive workflow for fulfilling customer orders, coordinating payment processing, inventory management, and customer notifications. Extracting them creates a focused class responsible for the complete order fulfillment process, improving separation of concerns and making the complex orchestration logic more testable and reusable.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of an order transaction - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order, including payment processing (generateTransactionId, processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus), and customer communications (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail).\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain - the complete process of taking an order from payment through completion. They form a cohesive workflow that coordinates multiple subsystems (payment, inventory, notifications) to fulfill customer orders. The orderProcessor field likely coordinates these operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates order fulfillment logic from other concerns\n- Code reusability: Order fulfillment logic can be reused across different order types or contexts\n- Complexity reduction: Removes complex orchestration logic from the original class\n- Testability: Order fulfillment scenarios can be tested in isolation with mock dependencies\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate complex workflow orchestration. It creates a Facade pattern that coordinates multiple subsystems (payment, inventory, notifications) behind a simplified interface for order fulfillment operations.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for fulfilling orders - from applying discounts and calculating totals to configuring shipping and estimating delivery. Extracting them into OrderFulfillment separates fulfillment concerns from order management, improving cohesion and enabling independent testing of fulfillment logic.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, estimate delivery, configure shipping details, and track changes. The primary responsibility is orchestrating the fulfillment process from discount application through delivery estimation.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They work together to transform an order from its initial state to a fulfilled state by applying business rules (discounts, tiers), calculating final amounts, setting up shipping logistics, and tracking the process through audit logging.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates fulfillment logic from other order concerns like creation or payment\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Original class becomes simpler by removing fulfillment-specific calculations and logistics\n- Testability: Fulfillment scenarios can be tested in isolation with mock dependencies\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The cohesive set of operations (discount calculation, shipping configuration, delivery estimation) represents a distinct phase in the order lifecycle that can be encapsulated independently while maintaining low coupling with the original order class.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
