{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "buildOrderConfirmationEmailBody()",
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "totalAmount",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7133811512762811,
      "coupling": 0.8640884023668597,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ],
      "cohesion": 0.702529660306584,
      "coupling": 0.9310777909081736,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7512555920693468,
      "coupling": 0.9956027457515872,
      "quality_score": 35.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.685454545454545,
      "coupling": 0.909410790341172,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 0.8881302937777512,
      "quality_score": 40.0
    },
    {
      "id": 5,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 6,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for calculating all financial aspects of an order including shipping, discounts, taxes, and totals. Extracting them into an OrderPriceCalculator class isolates pricing logic from order management, improving testability and enabling reuse across different order processing contexts.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes, totals) and provide breakdowns of pricing information. All methods are focused on computing and retrieving different aspects of order pricing.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Pricing\" domain concept. They form a cohesive subsystem that handles all financial calculations related to an order, including base pricing, shipping, discounts, taxes, and final totals. The orderPriceCalculator field suggests this is already a partially extracted calculation component.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing calculation logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts (cart, checkout, invoicing)\n- Complexity reduction: Removes financial calculation complexity from the main order class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate calculation concerns from order management. It creates a specialized Calculator object that encapsulates complex pricing algorithms, following the principle of high cohesion (all methods calculate prices) and low coupling (minimal dependencies on order state).\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart abstraction that manages a collection of items with quantities, handles inventory validation, and performs cart-level calculations. Extracting them creates a reusable component that encapsulates all cart-related behavior while maintaining clear boundaries with inventory and audit systems.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle inventory-related operations. The core responsibility is maintaining an item catalog with quantities, tracking stock levels, performing calculations on the collection, and coordinating with warehouse inventory systems.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"shopping cart\" or \"order basket\" domain. They represent a temporary collection of items that a customer intends to purchase, along with quantity management and inventory validation. The methods handle adding/removing items, quantity updates, stock checking, and total calculations - all classic shopping cart operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart management logic from other business concerns\n- Code reusability: Cart functionality can be reused across different ordering contexts (web, mobile, API)\n- Complexity reduction: Removes item collection management complexity from the parent class\n- Testability: Cart operations can be unit tested independently with mock inventory systems\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a cohesive aggregate that encapsulates item collection behavior. It represents a classic Domain-Driven Design aggregate where the cart maintains consistency of its items and coordinates with external inventory systems.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ]
    },
    {
      "class_name": "OrderTransactionWorkflow",
      "rationale": "These methods form a cohesive workflow that orchestrates the complete order transaction process, coordinating payment processing, inventory management, and customer notifications. Extracting them creates a focused class responsible for managing the multi-step transaction lifecycle while reducing complexity in the original class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order transactions - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order transaction successfully.\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"order transaction\" domain. They represent the coordinated workflow that occurs when processing an order: payment handling (generateTransactionId, processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus), and customer communication (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail). The orderProcessor field likely coordinates these operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates transaction workflow logic from other business concerns\n- Testability: Transaction scenarios can be unit tested independently with mocked dependencies\n- Reusability: Transaction logic can be reused across different order types or channels\n- Complexity reduction: Removes complex multi-step workflow logic from the original class\n- Maintainability: Changes to transaction flow are localized to one class\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate complex workflow orchestration. The methods represent a cohesive transaction workflow that coordinates multiple subsystems (payment, inventory, notifications) to complete a business transaction atomically.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for order fulfillment operations including discount application, total calculation, shipping configuration, and delivery estimation. Extracting them creates a focused class that encapsulates the complete fulfillment workflow while reducing complexity in the original order class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, estimate delivery, configure shipping details, and track changes. The primary responsibility is orchestrating the fulfillment process from pricing through delivery estimation.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They work together to transform an order from its initial state through pricing calculations, shipping configuration, and delivery planning. The shipping address fields form a cohesive data structure, while methods like applyDiscount, calculateTotalAmount, and estimateDeliveryDate represent the fulfillment workflow.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates fulfillment logic from other order concerns (creation, payment, etc.)\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Original class becomes simpler by removing fulfillment-specific calculations and configurations\n- Testability: Fulfillment scenarios can be tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The methods exhibit high cohesion as they all contribute to the fulfillment process, and the extraction creates low coupling by encapsulating fulfillment-specific data and operations.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
