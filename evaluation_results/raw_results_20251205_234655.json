{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7290322580645164,
      "coupling": 0.9359708485163972,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7454545454545456,
      "coupling": 1.0,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ],
      "cohesion": 0.6766666666666666,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6363636363636366,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.6571428571428571,
      "coupling": 0.9565217391304346,
      "quality_score": 30.0
    },
    {
      "id": 5,
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 6,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 8,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for calculating all monetary aspects of an order including shipping, taxes, discounts, and totals. Extracting them into an OrderPriceCalculator class isolates financial computation logic and improves both testability and reusability across different order processing contexts.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes, totals) and provide breakdowns of pricing information. All methods are focused on computing and retrieving different aspects of order pricing.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Pricing\" domain concept. They form a cohesive subsystem that handles all monetary calculations related to an order, including base pricing, shipping, taxes, discounts, and final totals. The orderPriceCalculator field suggests this is already a partially extracted calculation component.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing calculation logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts (quotes, invoices, receipts)\n- Complexity reduction: Removes complex financial logic from the main class, making it more focused on its core responsibility\n- Testability: Pricing calculations can be unit tested in isolation with various scenarios and edge cases\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate financial calculation concerns. It creates a Calculator pattern that encapsulates complex pricing logic and provides a clean interface for monetary computations. This improves cohesion by grouping related calculations and reduces coupling by isolating pricing logic from other business concerns.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive unit responsible for managing a collection of items with quantities and performing cart-related calculations. Extracting them into a ShoppingCart class creates a focused domain object that encapsulates cart state and behavior, improving reusability and separating cart concerns from broader order processing logic.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle calculations related to those items. The core responsibility is maintaining an item collection state - adding, removing, updating quantities, and performing calculations based on the current item state. Methods like addItem, removeItem, updateItemQuantity manage the collection, while recalculateSubtotal, calculateTotalAmount perform computations on the collection data.\n\nStep 2: Shared Concept/Domain\nThese members represent a \"Shopping Cart\" or \"Order Basket\" domain concept. They encapsulate the behavior of a container that holds items with quantities, tracks inventory, and calculates totals. The items and itemQuantities fields store the cart state, while methods provide cart operations. The buildOrderConfirmationEmailBody and logAudit methods also operate on this cart context.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart management logic from other business concerns\n- Code Reusability: Cart functionality can be reused across different order contexts (web, mobile, API)\n- Complexity Reduction: Original class becomes simpler by removing cart-specific state and operations\n- Testability: Cart logic can be unit tested independently with focused test scenarios\n- Encapsulation: Cart state (items, quantities) is properly encapsulated with its related operations\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate the \"cart\" concern from broader order processing. The extracted class will have high cohesion (all methods operate on cart items) and low coupling (minimal dependencies beyond basic item data). This creates a reusable component that encapsulates cart behavior as a domain object.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "logAudit(String)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "items",
        "itemQuantities",
        "totalAmount"
      ]
    },
    {
      "class_name": "WarehouseInventoryTracker",
      "rationale": "These methods and field form a cohesive inventory management unit that tracks warehouse stock levels, updates quantities, and maintains audit logs. Extracting them into a WarehouseInventoryTracker class improves separation of concerns by isolating all inventory-related operations from business logic.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage warehouse inventory operations. getLowStockItems(int) identifies items below a threshold, updateWarehouseStock(String,int) modifies inventory quantities, and logAudit(String) records inventory-related activities. The warehouseInventoryTracker field supports these operations by maintaining inventory state.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"warehouse inventory management\" domain. They represent a cohesive subsystem that tracks stock levels, updates quantities, identifies low-stock situations, and maintains audit trails for inventory changes. This is a well-defined business capability.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all warehouse inventory concerns into one class\n- Code reusability: Inventory tracking logic can be reused across different warehouse operations\n- Complexity reduction: Removes inventory management complexity from the original class\n- Testability: Inventory operations can be unit tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate inventory management concerns. The extracted class will have high cohesion (all methods work with warehouse inventory) and low coupling (minimal dependencies beyond inventory data structures).\n",
      "methods": [
        "getLowStockItems(int)",
        "logAudit(String)",
        "updateWarehouseStock(String,int)"
      ],
      "fields": [
        "warehouseInventoryTracker"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for order fulfillment operations including discount application, shipping configuration, and delivery estimation. Extracting them creates a focused class that encapsulates all fulfillment-related logic while reducing complexity in the original order class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations including discount application, pricing calculations, shipping configuration, and delivery estimation. The primary responsibility is managing the fulfillment aspects of an order - from pricing adjustments to shipping logistics.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They encompass discount management (applyDiscount, applyTierDiscount), pricing calculations (calculateTotalAmount), shipping logistics (setShippingAddress, setShippingMethod, estimateDeliveryDate), and customer tier handling (setCustomerTier). The shipping address fields form a cohesive data structure, and the discountCalculator field supports the pricing operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates fulfillment logic from other order concerns like creation or validation\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Removes complex pricing and shipping calculations from the main order class\n- Testability: Fulfillment scenarios can be tested independently with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The extracted class will have high cohesion as all methods work together to fulfill an order, and low coupling since fulfillment operations are relatively self-contained with minimal external dependencies.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    },
    {
      "class_name": "OrderTransactionOrchestrator",
      "rationale": "These methods form a cohesive transaction workflow that orchestrates payment processing, inventory management, and customer notifications for order completion. Extracting them creates a focused component responsible for coordinating the multiple steps required to successfully process an order transaction from start to finish.",
      "confidence": 0.75,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of an order transaction - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order, including payment processing (generateTransactionId, processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus), and customer communications (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail).\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Transaction\" domain - the complete business transaction that occurs when processing an order. They form a cohesive workflow that manages the transactional aspects of order processing, ensuring payments are handled, inventory is properly managed, and customers are notified of transaction outcomes.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates transaction orchestration logic from other order concerns\n- Improved Testability: Transaction workflows can be unit tested independently with mocked dependencies\n- Enhanced Reusability: Transaction logic can be reused across different order types or contexts\n- Reduced Complexity: Original class becomes more focused on its core responsibilities\n- Better Error Handling: Transaction-specific error scenarios can be handled in one place\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate transaction orchestration concerns. The extracted class will have high cohesion as all methods work together to complete order transactions, and can maintain low coupling by accepting necessary data as parameters rather than depending on the entire original class structure.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    }
  ]
}
