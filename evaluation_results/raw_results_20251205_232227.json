{
  "clusters_all": [
    {
      "id": 3,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "buildOrderConfirmationEmailBody()",
        "calculateShippingCost()",
        "checkInventoryAvailability()",
        "clearItems()",
        "generateOrderId()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "getOrderDate()",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerName",
        "orderDate",
        "items",
        "itemQuantities",
        "warehouseStock",
        "reservedItems",
        "lastModified"
      ],
      "cohesion": 0.6745098039215682,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 2,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "logAudit(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "discountPercentage"
      ],
      "cohesion": 0.9,
      "coupling": 0.8611111111111112,
      "quality_score": 40.0
    },
    {
      "id": 8,
      "methods": [
        "calculateTotalAmount()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getTaxAmount()",
        "getTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "subtotal",
        "taxRate",
        "shippingCost"
      ],
      "cohesion": 0.8266666666666667,
      "coupling": 0.9127565982404691,
      "quality_score": 40.0
    },
    {
      "id": 0,
      "methods": [
        "estimateDeliveryDate()",
        "getShippingMethodMultiplier()",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()"
      ],
      "fields": [
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry"
      ],
      "cohesion": 0.72,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 5,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "logAudit(String)",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6333333333333334,
      "coupling": 1.0,
      "quality_score": 25.0
    },
    {
      "id": 11,
      "methods": [
        "getAuditLog()"
      ],
      "fields": [
        "auditLog"
      ],
      "cohesion": 0.8,
      "coupling": 0.8749999999999999,
      "quality_score": 30.0
    },
    {
      "id": 12,
      "methods": [
        "getCustomerEmail()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "sendEmail(String,String,String)",
        "logAudit(String)",
        "buildOrderConfirmationEmailBody()"
      ],
      "fields": [
        "customerEmail",
        "orderId"
      ],
      "cohesion": 0.709090909090909,
      "coupling": 1.0,
      "quality_score": 40.0
    },
    {
      "id": 6,
      "methods": [
        "getCustomerId()"
      ],
      "fields": [
        "customerId"
      ],
      "cohesion": 0.8,
      "coupling": 0.8749999999999999,
      "quality_score": 30.0
    },
    {
      "id": 9000,
      "methods": [
        "setCustomerTier(String)"
      ],
      "fields": [
        "customerTier"
      ],
      "cohesion": 0.8,
      "coupling": 1.0,
      "quality_score": 30.0
    },
    {
      "id": 9001,
      "methods": [],
      "fields": [
        "shippingMethod"
      ],
      "cohesion": 0.0,
      "coupling": 0.8000000000000002,
      "quality_score": 0.0
    },
    {
      "id": 1,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 4,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 10,
      "methods": [],
      "fields": [
        "totalAmount"
      ],
      "cohesion": 0.0,
      "coupling": 0.8,
      "quality_score": 0.0
    },
    {
      "id": 7,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.8,
      "quality_score": 0.0
    }
  ],
  "suggestions": [
    {
      "class_name": "PriceCalculator",
      "rationale": "These methods and fields form a cohesive unit responsible for all pricing calculations including discounts, taxes, and shipping costs. Extracting them into a PriceCalculator class centralizes financial logic, improves testability, and allows the pricing engine to be reused across different contexts while following the Single Responsibility Principle.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of calculating and managing financial aspects of an order or transaction. They handle price calculations (total amount, discounts, taxes), shipping cost computations, and provide detailed breakdowns of pricing components. All methods work together to determine the final financial details of a purchase.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"pricing\" or \"financial calculation\" domain. They represent the mathematical and business logic needed to compute costs, apply discounts, calculate taxes, and determine shipping fees. The fields (subtotal, taxRate, shippingCost) serve as the data foundation for the calculation methods.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing logic into one focused class\n- Code Reusability: Pricing calculations can be reused across different order types or contexts\n- Complexity Reduction: Removes financial calculation complexity from the original class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n- Maintainability: Changes to pricing rules are centralized in one location\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate financial calculation concerns. It creates a cohesive unit that encapsulates the \"Calculate Price\" responsibility, following the Single Responsibility Principle. The extracted class will have high cohesion (all methods relate to pricing) and can be designed with low coupling to external dependencies.\n",
      "methods": [
        "calculateTotalAmount()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getTaxAmount()",
        "getTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "subtotal",
        "taxRate",
        "shippingCost"
      ]
    },
    {
      "class_name": "OrderNotificationService",
      "rationale": "These methods and fields form a cohesive unit responsible for managing order-related email communications and audit logging. Extracting them into an OrderNotificationService improves separation of concerns by isolating notification logic from core order processing, while providing a reusable service for order communication workflows.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of managing order-related email communications. They handle retrieving order information (getCustomerEmail, getOrderId), composing email content (buildOrderConfirmationEmailBody), sending different types of order emails (sendOrderConfirmationEmail, sendShippingNotificationEmail), and maintaining audit trails for these communications (logAudit). The sendEmail method appears to be a generic email sending utility that supports the specific order email operations.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"Order Communication\" domain. They represent a cohesive subsystem focused on notifying customers about their order status through email channels. The fields (customerEmail, orderId) provide the essential data context, while the methods orchestrate the email notification workflow for order-related events.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates email communication logic from other business concerns\n- Code reusability: The notification system can be reused across different order processing workflows\n- Complexity reduction: Removes email-specific logic from the main order processing class\n- Testability: Email notifications can be independently tested and mocked\n- Maintainability: Changes to email templates or notification logic are centralized\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate communication concerns from core business logic. It aligns with the Single Responsibility Principle by creating a focused class that handles only order-related notifications. The extraction also supports the Dependency Inversion Principle, as the main class can depend on an abstraction of the notification service rather than concrete email implementation details.\n",
      "methods": [
        "getCustomerEmail()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "sendEmail(String,String,String)",
        "logAudit(String)",
        "buildOrderConfirmationEmailBody()"
      ],
      "fields": [
        "customerEmail",
        "orderId"
      ]
    },
    {
      "class_name": "OrderProcessor",
      "rationale": "These methods form a cohesive order processing workflow that handles the complete lifecycle from payment processing to inventory management and customer notifications. Extracting them into an OrderProcessor class creates a focused service that encapsulates all order fulfillment responsibilities, improving maintainability and enabling better testing of the order processing business logic.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order processing and fulfillment. They manage transaction generation, payment processing (including refunds), inventory management (reservation and release), status tracking, audit logging, and customer communication through emails. The methods work together to orchestrate a complete order workflow from payment to fulfillment.\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"Order Management\" or \"Order Fulfillment\" domain. They represent a cohesive subsystem that handles the business process of taking an order from initial processing through payment, inventory management, and customer notification. The orderProcessor field suggests this cluster already has some organizational structure around order processing.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all order processing logic into one focused class\n- Code reusability: Order processing logic can be reused across different parts of the application\n- Complexity reduction: Removes complex order workflow logic from the original God class\n- Testability: Order processing scenarios can be tested in isolation with mock dependencies\n- Maintainability: Changes to order processing workflow are contained within a single class\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a Service or Manager class that encapsulates a complete business process. It implements the Single Responsibility Principle by focusing solely on order processing concerns and reduces coupling by isolating order-related dependencies.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "logAudit(String)",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderPricingCalculator",
      "rationale": "These methods form a cohesive unit responsible for all financial calculations related to order pricing, including discounts, shipping costs, and total amounts. Extracting them into an OrderPricingCalculator improves separation of concerns by isolating complex pricing logic and makes the financial calculations more testable and reusable across different order contexts.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of calculating and applying various financial aspects of an order or transaction. They handle discount application (both general and tier-based), cost calculations (total amount and shipping), and audit logging of these financial operations. The discountPercentage field supports the discount-related calculations.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Pricing\" or \"Financial Calculation\" domain. They form a cohesive subsystem that manages all monetary computations including discounts, shipping costs, and total amount calculations, along with audit trail functionality for these financial operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing/financial calculation logic into one focused class\n- Code reusability: Pricing logic can be reused across different order types or contexts\n- Complexity reduction: Removes financial calculation complexity from the original class\n- Testability: Financial calculations can be unit tested independently with various discount and shipping scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate financial calculation concerns. It creates a cohesive Calculator or Strategy pattern implementation that encapsulates all order pricing logic, improving maintainability and allowing for easier modification of pricing rules.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "logAudit(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()",
        "getShippingMethodMultiplier()"
      ],
      "fields": [
        "discountPercentage"
      ]
    },
    {
      "class_name": "ShippingManager",
      "rationale": "These members form a cohesive shipping management unit that handles address configuration, cost calculations, delivery estimations, and shipping method selection. Extracting them into a ShippingManager class improves separation of concerns by isolating shipping logic from other business operations, while providing a reusable component for shipping-related functionality.",
      "confidence": 0.9,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle shipping-related operations for an order or transaction. They manage shipping address information, calculate shipping costs based on methods and destinations, estimate delivery dates, and track shipping-related changes through audit logging. The primary responsibility is managing all aspects of shipping logistics.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"shipping\" domain concept. The fields represent shipping destination data (address components), while the methods perform shipping calculations, estimations, and configuration. This forms a cohesive subsystem that encapsulates shipping business logic and data together.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates shipping logic from other business concerns like payment or inventory\n- Code Reusability: Shipping logic can be reused across different order types or contexts\n- Complexity Reduction: Removes shipping complexity from the main class, making it more focused\n- Testability: Shipping calculations and logic can be tested independently with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate shipping concerns. It creates a cohesive module following the principle of high cohesion (all members work together for shipping) and enables low coupling by encapsulating shipping logic away from other business domains.\n",
      "methods": [
        "estimateDeliveryDate()",
        "getShippingMethodMultiplier()",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)",
        "calculateTotalAmount()",
        "calculateShippingCost()"
      ],
      "fields": [
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry"
      ]
    }
  ]
}
