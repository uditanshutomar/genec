{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "buildOrderConfirmationEmailBody()",
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "totalAmount",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7133811512762812,
      "coupling": 0.8640884023668597,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ],
      "cohesion": 0.702529660306584,
      "coupling": 0.9310777909081734,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7512555920693466,
      "coupling": 0.9956027457515877,
      "quality_score": 35.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.685454545454545,
      "coupling": 0.909410790341172,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 0.8881302937777514,
      "quality_score": 40.0
    },
    {
      "id": 5,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 6,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for calculating all monetary aspects of an order including shipping, discounts, taxes, and totals. Extracting them into an OrderPriceCalculator class isolates financial computation logic and creates a reusable component that can handle complex pricing scenarios independently.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes) and provide breakdowns and totals. All methods are focused on computing and retrieving different aspects of order pricing.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Pricing\" domain concept. They form a cohesive calculation engine that handles all monetary computations related to an order, including base pricing, shipping, discounts, taxes, and final totals. The orderPriceCalculator field likely serves as a dependency for these calculations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts\n- Complexity reduction: Removes financial calculation complexity from the original class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate financial calculation concerns. It creates a specialized calculator that encapsulates order pricing logic, following the principle of high cohesion (all methods relate to price calculation) and enabling low coupling with the original class.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart abstraction that manages item collections, quantities, and inventory-aware operations. Extracting them creates a reusable cart component that encapsulates all item management logic while maintaining clear separation from other business concerns.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a shopping cart or order's line items. They handle adding/removing items, tracking quantities, checking inventory availability, calculating totals, and maintaining stock levels. The core responsibility is managing the collection of items in a transactional context with inventory awareness.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"shopping cart\" or \"order basket\" domain. They represent a cohesive unit that maintains items, their quantities, and provides cart-specific operations like subtotal calculation and inventory validation. The fields (items, itemQuantities, warehouseInventoryTracker) directly support these cart operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart/basket management from other business logic\n- Code Reusability: Cart functionality can be reused across different order contexts (web, mobile, API)\n- Complexity Reduction: Original class becomes simpler by removing cart-specific concerns\n- Testability: Cart logic can be unit tested independently with mock inventory systems\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate cart management concerns. The extracted class will have high cohesion (all methods operate on cart items) and low coupling (depends only on inventory tracking). It represents a classic domain object that encapsulates both data (items, quantities) and behavior (add, remove, calculate).\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ]
    },
    {
      "class_name": "OrderTransactionWorkflow",
      "rationale": "These methods represent a cohesive workflow for processing order transactions, encompassing payment processing, inventory management, and customer notifications. Extracting them creates a focused class responsible for orchestrating the complete transaction lifecycle, improving maintainability and testability of complex order processing logic.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order transactions - from payment processing and inventory management to customer notifications. They manage the orchestration of multiple business operations that must happen together to complete an order transaction successfully.\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"order transaction\" domain. They represent the coordinated workflow that occurs when processing an order: payment handling (generateTransactionId, processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus), and customer communication (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail). The orderProcessor field likely coordinates these operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates transaction workflow logic from other concerns\n- Improved Testability: Transaction scenarios can be tested independently with mocked dependencies\n- Enhanced Reusability: Transaction logic can be reused across different order types or channels\n- Reduced Complexity: Original class becomes simpler by removing complex transaction orchestration\n- Better Maintainability: Changes to transaction flow are contained within one class\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate transaction workflow concerns. The extracted class represents a Transaction Script pattern where related operations for a single business transaction are grouped together. This improves cohesion by keeping transaction-related operations together while reducing coupling with the original class.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods and fields form a cohesive unit responsible for processing orders from initial pricing through shipping preparation. They work together to apply discounts, calculate totals, determine shipping logistics, and maintain audit trails - all core aspects of order fulfillment operations.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, determine delivery logistics, and track changes. The methods work together to process an order from pricing through shipping preparation, including audit trail maintenance.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They encapsulate the business logic needed to transform a basic order into a fully processed, ready-to-ship order with calculated pricing, applied discounts, shipping details, and audit logging.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates order processing logic from other concerns\n- Code Reusability: Order fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Removes complex pricing and shipping calculations from the main class\n- Testability: Order fulfillment scenarios can be tested independently with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate order fulfillment concerns. The extracted class will have high cohesion (all methods contribute to order processing) and can be designed with clear interfaces to minimize coupling with the original class.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
