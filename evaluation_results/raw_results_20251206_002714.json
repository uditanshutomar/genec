{
  "clusters_all": [
    {
      "id": 0,
      "methods": [
        "buildOrderConfirmationEmailBody()",
        "generateOrderId()",
        "getAuditLog()",
        "getCustomerEmail()",
        "getCustomerId()",
        "getOrderDate()",
        "getOrderId()",
        "sendOrderConfirmationEmail()",
        "sendShippingNotificationEmail(String)",
        "<init>(String,String,String)"
      ],
      "fields": [
        "customerId",
        "customerEmail",
        "customerName",
        "orderId",
        "orderDate",
        "totalAmount",
        "reservedItems",
        "auditLog",
        "lastModified"
      ],
      "cohesion": 0.7133811512762812,
      "coupling": 0.8640884023668597,
      "quality_score": 35.0
    },
    {
      "id": 1,
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ],
      "cohesion": 0.7025296603065841,
      "coupling": 0.9310777909081734,
      "quality_score": 35.0
    },
    {
      "id": 2,
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ],
      "cohesion": 0.7512555920693466,
      "coupling": 0.9956027457515877,
      "quality_score": 35.0
    },
    {
      "id": 3,
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ],
      "cohesion": 0.6854545454545451,
      "coupling": 0.9094107903411719,
      "quality_score": 25.0
    },
    {
      "id": 4,
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ],
      "cohesion": 0.7000000000000001,
      "coupling": 0.8881302937777512,
      "quality_score": 40.0
    },
    {
      "id": 5,
      "methods": [
        "validatePaymentDetails(String,String)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 6,
      "methods": [
        "<init>(String,String,BigDecimal,int)"
      ],
      "fields": [],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    },
    {
      "id": 7,
      "methods": [],
      "fields": [
        "packageWeight"
      ],
      "cohesion": 0.0,
      "coupling": 0.0,
      "quality_score": 20.0
    }
  ],
  "suggestions": [
    {
      "class_name": "OrderPriceCalculator",
      "rationale": "These methods form a cohesive unit responsible for all order-related price calculations including shipping, discounts, taxes, and totals. Extracting them into an OrderPriceCalculator class isolates financial computation logic and improves reusability across different order processing contexts.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods share the primary responsibility of performing financial calculations for an order. They calculate various monetary components (shipping costs, discounts, taxes) and provide breakdowns and totals. The orderPriceCalculator field supports these calculations, indicating this cluster handles all price-related computations.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"order pricing\" domain. They represent a cohesive financial calculation subsystem that transforms order data into monetary values. This is a classic computational responsibility that operates on order information to produce pricing results.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates all pricing logic into one focused class\n- Code reusability: Pricing calculations can be reused across different order contexts (quotes, invoices, receipts)\n- Complexity reduction: Removes financial calculation complexity from the main order class\n- Testability: Pricing logic can be unit tested independently with various scenarios\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate computational concerns. The Calculator pattern is appropriate here as these methods perform related mathematical operations on order data to produce financial results.\n",
      "methods": [
        "calculateShippingCost()",
        "getDiscountAmount()",
        "getPriceBreakdown()",
        "getShippingMethodMultiplier()",
        "getTaxAmount()",
        "getTotalAmount()"
      ],
      "fields": [
        "orderPriceCalculator"
      ]
    },
    {
      "class_name": "ShoppingCart",
      "rationale": "These methods and fields form a cohesive shopping cart abstraction that manages a collection of items with quantities, handles inventory validation, and calculates totals. Extracting them creates a reusable component that encapsulates all cart-related operations and follows the single responsibility principle.",
      "confidence": 0.92,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively manage a collection of items with their quantities and handle inventory-related operations. The core responsibility is maintaining an item catalog with quantities, tracking stock levels, performing inventory checks, and calculating totals based on the items and their quantities.\n\nStep 2: Shared Concept/Domain\nAll members belong to the \"shopping cart\" or \"order basket\" domain. They represent a temporary collection of items that a customer intends to purchase, along with operations to modify this collection, check availability, and calculate totals. The methods operate on the shared state of items and their quantities.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates cart/basket management from other business logic\n- Code reusability: Cart functionality can be reused across different ordering contexts\n- Complexity reduction: Removes item collection management complexity from the parent class\n- Testability: Cart operations can be tested independently with focused unit tests\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a cohesive data structure with its associated operations. It represents the \"Shopping Cart\" pattern commonly found in e-commerce systems, where items are temporarily held before checkout.\n",
      "methods": [
        "addItem(String,String,BigDecimal,int)",
        "checkInventoryAvailability()",
        "clearItems()",
        "getItemCount()",
        "getItems()",
        "getItemsByCategory(String)",
        "getLowStockItems(int)",
        "logAudit(String)",
        "recalculateSubtotal()",
        "removeItem(String)",
        "updateItemQuantity(String,int)",
        "updateWarehouseStock(String,int)",
        "calculateTotalAmount()"
      ],
      "fields": [
        "warehouseInventoryTracker",
        "items",
        "itemQuantities"
      ]
    },
    {
      "class_name": "OrderFulfillment",
      "rationale": "These methods represent a cohesive workflow that orchestrates the complete order fulfillment process, coordinating payment processing, inventory management, and customer notifications. Extracting them creates a focused class responsible for managing the multi-step transaction lifecycle from order placement to completion.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle the complete lifecycle of order transactions - from payment processing and inventory management to customer notifications. The methods cover payment operations (processPayment, refundPayment, simulatePaymentGateway), inventory operations (reserveInventory, releaseInventory), status tracking (getOrderStatus, generateTransactionId), and customer communication (sendEmail, sendPaymentConfirmationEmail, sendRefundNotificationEmail).\n\nStep 2: Shared Concept/Domain\nAll methods belong to the \"order transaction\" domain, representing the orchestration of multiple business operations required to complete an order. They work together to ensure payment is processed, inventory is managed, and customers are notified throughout the transaction lifecycle. The orderProcessor field likely coordinates these operations.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates transaction orchestration logic from other business concerns\n- Code reusability: Transaction logic can be reused across different order types or contexts\n- Complexity reduction: Removes complex multi-step transaction logic from the original class\n- Testability: Transaction scenarios can be tested in isolation with mock dependencies\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to create a Transaction Script or Facade that encapsulates the complex multi-step process of order fulfillment. It represents a cohesive workflow that coordinates multiple subsystems (payment, inventory, notifications) to complete a business transaction.\n",
      "methods": [
        "generateTransactionId()",
        "getOrderStatus()",
        "processPayment(String,String)",
        "refundPayment()",
        "releaseInventory()",
        "reserveInventory()",
        "sendEmail(String,String,String)",
        "sendPaymentConfirmationEmail()",
        "sendRefundNotificationEmail()",
        "simulatePaymentGateway(String,String,BigDecimal)"
      ],
      "fields": [
        "orderProcessor"
      ]
    },
    {
      "class_name": "OrderFulfillmentCalculator",
      "rationale": "These methods and fields form a cohesive unit responsible for calculating and coordinating order fulfillment - from applying discounts and computing totals to managing shipping details and estimating delivery. Extracting them creates a focused calculator that handles the computational aspects of order fulfillment while reducing complexity in the original order class.",
      "confidence": 0.88,
      "reasoning": "\nStep 1: Primary Responsibility Analysis\nThese methods collectively handle order fulfillment operations - they manage discounts, calculate totals, determine delivery dates, and handle shipping logistics. The primary responsibility is orchestrating the fulfillment process from pricing to delivery estimation.\n\nStep 2: Shared Concept/Domain\nThese members represent the \"Order Fulfillment\" domain concept. They work together to transform an order from its initial state through pricing calculations, shipping arrangements, and delivery planning. The shipping address fields form a cohesive data structure, while methods like applyDiscount, calculateTotalAmount, and estimateDeliveryDate represent the fulfillment workflow.\n\nStep 3: Extraction Benefits\n- Single Responsibility Principle: Isolates fulfillment logic from other order concerns (creation, payment, etc.)\n- Code Reusability: Fulfillment logic can be reused across different order types or contexts\n- Complexity Reduction: Original class becomes simpler by removing fulfillment-specific calculations and logistics\n- Testability: Fulfillment scenarios can be tested in isolation with mock data\n\nStep 4: Design Justification\nThis follows the Extract Class refactoring pattern to separate fulfillment concerns. The cohesive grouping of discount application, total calculation, shipping setup, and delivery estimation represents a distinct subdomain that can operate independently with well-defined inputs and outputs.\n",
      "methods": [
        "applyDiscount(BigDecimal)",
        "applyTierDiscount()",
        "calculateTotalAmount()",
        "estimateDeliveryDate()",
        "setCustomerTier(String)",
        "setShippingAddress(String,String,String,String)",
        "setShippingMethod(String)",
        "logAudit(String)"
      ],
      "fields": [
        "discountCalculator",
        "shippingAddress",
        "shippingCity",
        "shippingZipCode",
        "shippingCountry",
        "shippingMethod"
      ]
    }
  ]
}
