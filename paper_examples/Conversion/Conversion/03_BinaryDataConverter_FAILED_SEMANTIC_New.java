package org.apache.commons.lang3;
import java.util.UUID;
/** 
 * Extracted class generated by GenEC using Eclipse JDT.
 */
public class BinaryDataConverter {
  /** 
 * Converts a byte into an array of char using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the byte to convert.
 * @param srcPos  the position in {@code src}, in bits, from where to start the conversion.
 * @param dstInit the initial value for the result String.
 * @param dstPos  the position in {@code dst} where to copy the result.
 * @param nHexs   the number of chars to copy to {@code dst}, must be smaller or equal to the width of the input (from srcPos to MSB).
 * @return {@code dst}.
 * @throws IllegalArgumentException        if {@code (nHexs - 1) * 4 + srcPos >= 8}.
 * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}.
 */
  public static String byteToHex(  final byte src,  final int srcPos,  final String dstInit,  final int dstPos,  final int nHexs){
    if (0 == nHexs) {
      return dstInit;
    }
    if ((nHexs - 1) * 4 + srcPos >= Byte.SIZE) {
      throw new IllegalArgumentException("(nHexs - 1) * 4 + srcPos >= 8");
    }
    final StringBuilder sb=new StringBuilder(dstInit);
    int append=sb.length();
    for (int i=0; i < nHexs; i++) {
      final int shift=i * 4 + srcPos;
      final int bits=0xF & src >> shift;
      if (dstPos + i == append) {
        ++append;
        sb.append(intToHexDigit(bits));
      }
 else {
        sb.setCharAt(dstPos + i,intToHexDigit(bits));
      }
    }
    return sb.toString();
  }
  /** 
 * Converts a hexadecimal string into a byte using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the hexadecimal string to convert.
 * @param srcPos  the position in {@code src}, in char unit, from where to start the conversion.
 * @param dstInit initial value of the destination byte.
 * @param dstPos  the position of the LSB, in bits, in the result byte.
 * @param nHex    the number of Chars to convert.
 * @return a byte containing the selected bits.
 * @throws IllegalArgumentException if {@code (nHex-1)*4+dstPos >= 8}.
 */
  public static byte hexToByte(  final String src,  final int srcPos,  final byte dstInit,  final int dstPos,  final int nHex){
    if (0 == nHex) {
      return dstInit;
    }
    if ((nHex - 1) * 4 + dstPos >= Byte.SIZE) {
      throw new IllegalArgumentException("(nHex - 1) * 4 + dstPos >= 8");
    }
    byte out=dstInit;
    for (int i=0; i < nHex; i++) {
      final int shift=i * 4 + dstPos;
      final int bits=(0xf & Conversion.hexDigitToInt(src.charAt(i + srcPos))) << shift;
      final int mask=0xf << shift;
      out=(byte)(out & ~mask | bits);
    }
    return out;
  }
  /** 
 * Converts an array of char into an int using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the hexadecimal string to convert.
 * @param srcPos  the position in {@code src}, in char unit, from where to start the conversion.
 * @param dstInit initial value of the destination int.
 * @param dstPos  the position of the LSB, in bits, in the result int.
 * @param nHex    the number of chars to convert.
 * @return an int containing the selected bits.
 * @throws IllegalArgumentException if {@code (nHexs - 1) * 4 + dstPos >= 32}.
 */
  public static int hexToInt(  final String src,  final int srcPos,  final int dstInit,  final int dstPos,  final int nHex){
    if (0 == nHex) {
      return dstInit;
    }
    if ((nHex - 1) * 4 + dstPos >= Integer.SIZE) {
      throw new IllegalArgumentException("(nHexs - 1) * 4 + dstPos >= 32");
    }
    int out=dstInit;
    for (int i=0; i < nHex; i++) {
      final int shift=i * 4 + dstPos;
      final int bits=(0xf & Conversion.hexDigitToInt(src.charAt(i + srcPos))) << shift;
      final int mask=0xf << shift;
      out=out & ~mask | bits;
    }
    return out;
  }
  /** 
 * Converts an array of char into a long using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the hexadecimal string to convert.
 * @param srcPos  the position in {@code src}, in char unit, from where to start the conversion.
 * @param dstInit initial value of the destination long.
 * @param dstPos  the position of the LSB, in bits, in the result long.
 * @param nHex    the number of chars to convert.
 * @return a long containing the selected bits.
 * @throws IllegalArgumentException if {@code (nHexs - 1) * 4 + dstPos >= 64}.
 */
  public static long hexToLong(  final String src,  final int srcPos,  final long dstInit,  final int dstPos,  final int nHex){
    if (0 == nHex) {
      return dstInit;
    }
    if ((nHex - 1) * 4 + dstPos >= Long.SIZE) {
      throw new IllegalArgumentException("(nHexs - 1) * 4 + dstPos >= 64");
    }
    long out=dstInit;
    for (int i=0; i < nHex; i++) {
      final int shift=i * 4 + dstPos;
      final long bits=(0xfL & Conversion.hexDigitToInt(src.charAt(i + srcPos))) << shift;
      final long mask=0xfL << shift;
      out=out & ~mask | bits;
    }
    return out;
  }
  /** 
 * Converts an array of char into a short using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the hexadecimal string to convert.
 * @param srcPos  the position in {@code src}, in char unit, from where to start the conversion.
 * @param dstInit initial value of the destination short.
 * @param dstPos  the position of the LSB, in bits, in the result short.
 * @param nHex    the number of chars to convert.
 * @return a short containing the selected bits.
 * @throws IllegalArgumentException if {@code (nHexs - 1) * 4 + dstPos >= 16}.
 */
  public static short hexToShort(  final String src,  final int srcPos,  final short dstInit,  final int dstPos,  final int nHex){
    if (0 == nHex) {
      return dstInit;
    }
    if ((nHex - 1) * 4 + dstPos >= Short.SIZE) {
      throw new IllegalArgumentException("(nHexs - 1) * 4 + dstPos >= 16");
    }
    short out=dstInit;
    for (int i=0; i < nHex; i++) {
      final int shift=i * 4 + dstPos;
      final int bits=(0xf & Conversion.hexDigitToInt(src.charAt(i + srcPos))) << shift;
      final int mask=0xf << shift;
      out=(short)(out & ~mask | bits);
    }
    return out;
  }
  /** 
 * Converts an int into an array of char using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the int to convert.
 * @param srcPos  the position in {@code src}, in bits, from where to start the conversion.
 * @param dstInit the initial value for the result String.
 * @param dstPos  the position in {@code dst} where to copy the result.
 * @param nHexs   the number of chars to copy to {@code dst}, must be smaller or equal to the width of the input (from srcPos to MSB).
 * @return {@code dst}.
 * @throws IllegalArgumentException        if {@code (nHexs - 1) * 4 + srcPos >= 32}.
 * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}.
 */
  public static String intToHex(  final int src,  final int srcPos,  final String dstInit,  final int dstPos,  final int nHexs){
    if (0 == nHexs) {
      return dstInit;
    }
    if ((nHexs - 1) * 4 + srcPos >= Integer.SIZE) {
      throw new IllegalArgumentException("(nHexs - 1) * 4 + srcPos >= 32");
    }
    final StringBuilder sb=new StringBuilder(dstInit);
    int append=sb.length();
    for (int i=0; i < nHexs; i++) {
      final int shift=i * 4 + srcPos;
      final int bits=0xF & src >> shift;
      if (dstPos + i == append) {
        ++append;
        sb.append(intToHexDigit(bits));
      }
 else {
        sb.setCharAt(dstPos + i,intToHexDigit(bits));
      }
    }
    return sb.toString();
  }
  /** 
 * Converts the 4 LSB of an int to a hexadecimal digit. <p> 0 returns '0' </p> <p> 1 returns '1' </p> <p> 10 returns 'A' and so on... </p>
 * @param nibble the 4 bits to convert.
 * @return a hexadecimal digit representing the 4 LSB of {@code nibble}.
 * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}.
 */
  public static char intToHexDigit(  final int nibble){
    final char c=Character.forDigit(nibble,16);
    if (c == Character.MIN_VALUE) {
      throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);
    }
    return c;
  }
  /** 
 * Converts the 4 LSB of an int to a hexadecimal digit encoded using the MSB0 bit ordering. <p> 0 returns '0' </p> <p> 1 returns '8' </p> <p> 10 returns '5' and so on... </p>
 * @param nibble the 4 bits to convert.
 * @return a hexadecimal digit representing the 4 LSB of {@code nibble}.
 * @throws IllegalArgumentException if {@code nibble < 0} or {@code nibble > 15}.
 */
  public static char intToHexDigitMsb0(  final int nibble){
switch (nibble) {
case 0x0:      return '0';
case 0x1:    return '8';
case 0x2:  return '4';
case 0x3:return 'c';
case 0x4:return '2';
case 0x5:return 'a';
case 0x6:return '6';
case 0x7:return 'e';
case 0x8:return '1';
case 0x9:return '9';
case 0xA:return '5';
case 0xB:return 'd';
case 0xC:return '3';
case 0xD:return 'b';
case 0xE:return '7';
case 0xF:return 'f';
default:throw new IllegalArgumentException("nibble value not between 0 and 15: " + nibble);
}
}
/** 
 * Converts a long into an array of char using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the long to convert.
 * @param srcPos  the position in {@code src}, in bits, from where to start the conversion.
 * @param dstInit the initial value for the result String.
 * @param dstPos  the position in {@code dst} where to copy the result.
 * @param nHexs   the number of chars to copy to {@code dst}, must be smaller or equal to the width of the input (from srcPos to MSB).
 * @return {@code dst}.
 * @throws IllegalArgumentException        if {@code (nHexs - 1) * 4 + srcPos >= 64}.
 * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}.
 */
public static String longToHex(final long src,final int srcPos,final String dstInit,final int dstPos,final int nHexs){
if (0 == nHexs) {
return dstInit;
}
if ((nHexs - 1) * 4 + srcPos >= Long.SIZE) {
throw new IllegalArgumentException("(nHexs - 1) * 4 + srcPos >= 64");
}
final StringBuilder sb=new StringBuilder(dstInit);
int append=sb.length();
for (int i=0; i < nHexs; i++) {
final int shift=i * 4 + srcPos;
final int bits=(int)(0xF & src >> shift);
if (dstPos + i == append) {
++append;
sb.append(intToHexDigit(bits));
}
 else {
sb.setCharAt(dstPos + i,intToHexDigit(bits));
}
}
return sb.toString();
}
/** 
 * Converts a short into an array of char using the default (little-endian, LSB0) byte and bit ordering.
 * @param src     the short to convert.
 * @param srcPos  the position in {@code src}, in bits, from where to start the conversion.
 * @param dstInit the initial value for the result String.
 * @param dstPos  the position in {@code dst} where to copy the result.
 * @param nHexs   the number of chars to copy to {@code dst}, must be smaller or equal to the width of the input (from srcPos to MSB).
 * @return {@code dst}.
 * @throws IllegalArgumentException        if {@code (nHexs - 1) * 4 + srcPos >= 16}.
 * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}.
 */
public static String shortToHex(final short src,final int srcPos,final String dstInit,final int dstPos,final int nHexs){
if (0 == nHexs) {
return dstInit;
}
if ((nHexs - 1) * 4 + srcPos >= Short.SIZE) {
throw new IllegalArgumentException("(nHexs - 1) * 4 + srcPos >= 16");
}
final StringBuilder sb=new StringBuilder(dstInit);
int append=sb.length();
for (int i=0; i < nHexs; i++) {
final int shift=i * 4 + srcPos;
final int bits=0xF & src >> shift;
if (dstPos + i == append) {
++append;
sb.append(intToHexDigit(bits));
}
 else {
sb.setCharAt(dstPos + i,intToHexDigit(bits));
}
}
return sb.toString();
}
}
